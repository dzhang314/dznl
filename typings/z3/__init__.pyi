from typing import overload

class BoolRef(object):
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BoolRef
    ) -> BoolRef: ...
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BoolRef
    ) -> BoolRef: ...
    def sexpr(self) -> str: ...

def Bool(name: str) -> BoolRef: ...
def BoolVal(value: bool) -> BoolRef: ...
def is_true(arg: BoolRef) -> bool: ...
def is_false(arg: BoolRef) -> bool: ...
def Not(arg: BoolRef) -> BoolRef: ...
def And(*args: BoolRef) -> BoolRef: ...
def Or(*args: BoolRef) -> BoolRef: ...
def Xor(a: BoolRef, b: BoolRef) -> BoolRef: ...
def Implies(a: BoolRef, b: BoolRef) -> BoolRef: ...

class BitVecRef(object):
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BitVecRef
    ) -> BoolRef: ...
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: BitVecRef
    ) -> BoolRef: ...
    def __lt__(self, other: BitVecRef) -> BoolRef: ...
    def __le__(self, other: BitVecRef) -> BoolRef: ...
    def __gt__(self, other: BitVecRef) -> BoolRef: ...
    def __ge__(self, other: BitVecRef) -> BoolRef: ...
    def __add__(self, other: BitVecRef) -> BitVecRef: ...
    def __sub__(self, other: BitVecRef) -> BitVecRef: ...
    def size(self) -> int: ...
    def sexpr(self) -> str: ...

class BitVecNumRef(BitVecRef): ...

def BitVec(name: str, size: int) -> BitVecRef: ...
def BitVecVal(value: int, size: int) -> BitVecNumRef: ...
def Concat(*args: BitVecRef) -> BitVecRef: ...
def Extract(high: int, low: int, arg: BitVecRef) -> BitVecRef: ...
@overload
def If(c: BoolRef, a: BitVecRef, b: BitVecRef) -> BitVecRef: ...

class ArithRef(object):
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: int | ArithRef
    ) -> BoolRef: ...
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: int | ArithRef
    ) -> BoolRef: ...
    def __lt__(self, other: int | ArithRef) -> BoolRef: ...
    def __le__(self, other: int | ArithRef) -> BoolRef: ...
    def __gt__(self, other: int | ArithRef) -> BoolRef: ...
    def __ge__(self, other: int | ArithRef) -> BoolRef: ...
    def __add__(self, other: int | ArithRef) -> ArithRef: ...
    def __sub__(self, other: int | ArithRef) -> ArithRef: ...
    def sexpr(self) -> str: ...

def Int(name: str) -> ArithRef: ...
def IntVal(value: int) -> ArithRef: ...
def Abs(x: ArithRef) -> ArithRef: ...
@overload
def If(c: BoolRef, a: ArithRef, b: ArithRef) -> ArithRef: ...

class FPRef(object):
    def __eq__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: FPRef
    ) -> BoolRef: ...
    def __ne__(  # pyright: ignore [reportIncompatibleMethodOverride]
        self, other: FPRef
    ) -> BoolRef: ...
    def __add__(self, other: FPRef) -> FPRef: ...
    def __sub__(self, other: FPRef) -> FPRef: ...

def fpFP(sign_bit: BitVecRef, exponent: BitVecRef, mantissa: BitVecRef) -> FPRef: ...
def fpEQ(x: FPRef, y: FPRef) -> BoolRef: ...
def fpIsZero(x: FPRef) -> BoolRef: ...
def fpIsPositive(x: FPRef) -> BoolRef: ...
def fpIsNegative(x: FPRef) -> BoolRef: ...
def fpIsInf(x: FPRef) -> BoolRef: ...
def fpIsNaN(x: FPRef) -> BoolRef: ...
def fpIsSubnormal(x: FPRef) -> BoolRef: ...

class FPRMRef(object): ...

def RoundNearestTiesToEven() -> FPRMRef: ...
def fpAdd(rm: FPRMRef, x: FPRef, y: FPRef) -> FPRef: ...
def fpSub(rm: FPRMRef, x: FPRef, y: FPRef) -> FPRef: ...

class CheckSatResult(object): ...

sat: CheckSatResult
unsat: CheckSatResult
unknown: CheckSatResult

class IntNumRef(object):
    def as_long(self) -> int: ...

class ModelRef(object):
    @overload
    def __getitem__(self, key: BoolRef) -> BoolRef: ...
    @overload
    def __getitem__(self, key: ArithRef) -> IntNumRef: ...

class Solver(object):
    def add(self, expr: BoolRef) -> None: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...
    def check(self, *args: BoolRef) -> CheckSatResult: ...
    def model(self) -> ModelRef: ...
    def sexpr(self) -> str: ...
    def to_smt2(self) -> str: ...

def SolverFor(logic: str) -> Solver: ...
